name: CI ‚Äì Prematch HTML (DB-only)

on:
  workflow_dispatch: {}
  pull_request:
    branches: [ main ]

jobs:
  prematch-ci:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    env:
      # üëâ SOLO Postgres (sin PostgREST)
      DATABASE_URL: ${{ secrets.DATABASE_URL }}

      # Silenciar INFO de supabase_fs (esos ‚ÄúSUPABASE_URL / SUPABASE_KEY no configurados.‚Äù)
      LOG_LEVEL: WARNING

      # ‚ö†Ô∏è NO definimos SUPABASE_URL ni SUPABASE_KEY en Opci√≥n A
      # SUPABASE_URL: (no set)
      # SUPABASE_KEY: (no set)

      # Si quieres fallback a Sportradar en tiempo real, a√±ade tu API key:
      # SR_API_KEY: ${{ secrets.SR_API_KEY }}

      PYTHONUNBUFFERED: "1"
      FLASK_ENV: testing

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          # Dependencias t√≠picas del proyecto (ajusta si usas otras)
          pip install flask requests psycopg2-binary

      # (Opcional) sanity DB: que existe y responde
      - name: DB sanity check
        run: |
          psql "$DATABASE_URL" -c "select now();"
          # vistas/tablas necesarias para rank/YTD
          psql "$DATABASE_URL" -c "select count(*) from public.rankings_snapshot_int limit 1;" || true
          psql "$DATABASE_URL" -c "select * from public.v_player_rank_now_int order by rank asc limit 3;" || true
          psql "$DATABASE_URL" -c "select * from public.v_player_ytd_now_int  limit 3;" || true

      - name: Run prematch smoke tests (JSON + HTML)
        run: |
          python - << 'PY'
          import json
          from main import app

          client = app.test_client()

          # IDs de ejemplo (mismo espacio que fs_matches_long ‚Äì ajusta si usas otros)
          P_ID = 225050   # Sinner (ejemplo)
          O_ID = 407573   # Alcaraz (ejemplo)

          payload = {
              "player_id": P_ID,
              "opponent_id": O_ID,
              "tournament": {"name": "Cincinnati", "month": 8},
              "years_back": 4
          }

          # --- 1) JSON /matchup ---
          r = client.post("/matchup", json=payload)
          assert r.status_code == 200, r.data
          data = r.get_json()
          assert "extras" in data, "extras missing"
          ex = data["extras"]
          for k in ["rank_p","rank_o","ytd_wr_p","ytd_wr_o"]:
              assert k in ex, f"{k} missing in extras"
          print("[OK] /matchup extras:", {k: ex.get(k) for k in ["rank_p","rank_o","ytd_wr_p","ytd_wr_o"]})

          # --- 2) HTML /matchup/prematch ---
          r2 = client.post("/matchup/prematch", json=payload)
          assert r2.status_code == 200, r2.data
          html = r2.get_data(as_text=True)
          assert "window.resp" in html, "window.resp not injected in prematch HTML"
          print("[OK] /matchup/prematch HTML rendered with window.resp")
          PY
