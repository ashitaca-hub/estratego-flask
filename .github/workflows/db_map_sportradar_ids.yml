name: db-map-sportradar-ids

on:
  workflow_dispatch:
    inputs:
      p1_srid:
        description: "SR competitor number del Player 1 (ej. 225050)"
        required: true
      p1_uuid:
        description: "UUID del Player 1 (si lo sabes). Si no, usa p1_name o autodetección con SR_API_KEY"
        required: false
      p1_name:
        description: "Nombre del Player 1 en tu DB (ILIKE '%nombre%')"
        required: false
      p2_srid:
        description: "SR competitor number del Player 2 (ej. 407573)"
        required: false
      p2_uuid:
        description: "UUID del Player 2 (si lo sabes). Si no, usa p2_name o autodetección con SR_API_KEY"
        required: false
      p2_name:
        description: "Nombre del Player 2 en tu DB (ILIKE '%nombre%')"
        required: false
      run_smoke:
        description: "Probar /matchup tras mapear (true/false)"
        required: false
        default: "true"

jobs:
  map-and-verify:
    runs-on: ubuntu-latest
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}   # https://<ref>.supabase.co
      SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}   # service_role (secreta)
      SR_API_KEY: ${{ secrets.SR_API_KEY }}       # opcional (para deducir nombre desde Sportradar)
      SR_BASE: https://api.sportradar.com/tennis/trial/v3/en
      P1_SRID: ${{ github.event.inputs.p1_srid }}
      P1_UUID: ${{ github.event.inputs.p1_uuid }}
      P1_NAME: ${{ github.event.inputs.p1_name }}
      P2_SRID: ${{ github.event.inputs.p2_srid }}
      P2_UUID: ${{ github.event.inputs.p2_uuid }}
      P2_NAME: ${{ github.event.inputs.p2_name }}
      RUN_SMOKE: ${{ github.event.inputs.run_smoke }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prechecks
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${SUPABASE_URL:-}" ] || [ -z "${SUPABASE_KEY:-}" ]; then
            echo "::error::Faltan secrets SUPABASE_URL y/o SUPABASE_KEY (service_role)"; exit 1; fi
          if [ -z "${P1_SRID:-}" ]; then
            echo "::error::p1_srid es obligatorio"; exit 1; fi

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Funciones auxiliares (URLs seguras con --data-urlencode)
        shell: bash
        run: |
          set -euo pipefail
          cat > utils.sh <<'SH'
          set -euo pipefail
          BASE="${SUPABASE_URL%/}"

          find_candidates() {
            local NAME="$1"
            curl -sS -G "${BASE}/rest/v1/players" \
              -H "apikey: ${SUPABASE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_KEY}" \
              -H "Content-Type: application/json" \
              --data-urlencode "name=ilike.*${NAME}*" \
              --data-urlencode "select=player_id,name" \
              --data-urlencode "limit=5"
          }

          name_from_sr() {
            local SRID="$1"
            if [ -z "${SR_API_KEY:-}" ]; then echo ""; return 0; fi
            local URL="${SR_BASE}/competitors/sr:competitor:${SRID}/profile.json?api_key=${SR_API_KEY}"
            curl -sS "$URL" | jq -r '.competitor.name // empty'
          }

          clear_srid() {
            local SRID="$1"
            curl -sS -X PATCH "${BASE}/rest/v1/players?ext_sportradar_id=eq.${SRID}" \
              -H "apikey: ${SUPABASE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_KEY}" \
              -H "Content-Type: application/json" \
              -H "Prefer: return=representation" \
              -d '{"ext_sportradar_id": null}' > /dev/null
          }

          set_player_srid() {
            local UUID="$1"; local SRID="$2"
            curl -sS -X PATCH "${BASE}/rest/v1/players?player_id=eq.${UUID}" \
              -H "apikey: ${SUPABASE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_KEY}" \
              -H "Content-Type: application/json" \
              -H "Prefer: return=representation" \
              -d "{\"ext_sportradar_id\": \"${SRID}\"}" > /dev/null
          }

          verify_srid() {
            local SRID="$1"
            curl -sS -G "${BASE}/rest/v1/players" \
              -H "apikey: ${SUPABASE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_KEY}" \
              -H "Content-Type: application/json" \
              --data-urlencode "ext_sportradar_id=eq.${SRID}" \
              --data-urlencode "select=name,player_id,ext_sportradar_id" \
              --data-urlencode "limit=3" | jq .
          }
          SH
          chmod +x utils.sh

      - name: Map Player 1 (SRID → UUID con autodetección)
        shell: bash
        run: |
          set -euo pipefail
          . ./utils.sh
          UUID="${P1_UUID:-}"
          NAME_IN="${P1_NAME:-}"

          if [ -z "$UUID" ]; then
            if [ -z "$NAME_IN" ]; then
              NAME_IN="$(name_from_sr "$P1_SRID" || true)"
              if [ -n "$NAME_IN" ]; then
                echo "::notice::Nombre Player 1 según Sportradar: $NAME_IN"
              fi
            fi
            if [ -n "$NAME_IN" ]; then
              CANDS="$(find_candidates "$NAME_IN")"
              echo "== Candidatos Player 1 en DB =="; echo "$CANDS" | jq .
              UUID="$(echo "$CANDS" | jq -r '.[0].player_id // empty')"
            fi
          fi

          if [ -z "$UUID" ]; then
            echo "::error::No se encontró Player 1 (ni uuid ni name coincidente). Pasa p1_name tal como está en tu DB o p1_uuid."; exit 1; fi

          clear_srid "$P1_SRID"
          set_player_srid "$UUID" "$P1_SRID"
          echo "== Verificación Player 1 =="; verify_srid "$P1_SRID"

      - name: Map Player 2 (opcional, con autodetección)
        if: ${{ env.P2_SRID != '' || env.P2_UUID != '' || env.P2_NAME != '' }}
        shell: bash
        run: |
          set -euo pipefail
          . ./utils.sh
          if [ -z "${P2_SRID:-}" ]; then
            echo "::error::p2_srid requerido para Player 2"; exit 1; fi

          UUID="${P2_UUID:-}"
          NAME_IN="${P2_NAME:-}"

          if [ -z "$UUID" ]; then
            if [ -z "$NAME_IN" ]; then
              NAME_IN="$(name_from_sr "$P2_SRID" || true)"
              if [ -n "$NAME_IN" ]; then
                echo "::notice::Nombre Player 2 según Sportradar: $NAME_IN"
              fi
            fi
            if [ -n "$NAME_IN" ]; then
              CANDS="$(find_candidates "$NAME_IN")"
              echo "== Candidatos Player 2 en DB =="; echo "$CANDS" | jq .
              UUID="$(echo "$CANDS" | jq -r '.[0].player_id // empty')"
            fi
          fi

          if [ -z "$UUID" ]; then
            echo "::error::No se encontró Player 2 (ni uuid ni name coincidente). Pasa p2_name tal como está en tu DB o p2_uuid."; exit 1; fi

          clear_srid "$P2_SRID"
          set_player_srid "$UUID" "$P2_SRID"
          echo "== Verificación Player 2 =="; verify_srid "$P2_SRID"

      # ======= SMOKE /matchup (instala Python + deps y arranca app) =======
      - name: Setup Python (para smoke)
        if: ${{ env.RUN_SMOKE == 'true' }}
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Instalar dependencias de la API (para smoke)
        if: ${{ env.RUN_SMOKE == 'true' }}
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; else pip install flask requests; fi
          sudo apt-get update && sudo apt-get install -y jq

      - name: Arrancar app y esperar a que responda
        if: ${{ env.RUN_SMOKE == 'true' }}
        run: |
          set -euo pipefail
          nohup python -c "from main import app; app.run(host='127.0.0.1', port=8080)" >/dev/null 2>&1 &
          # espera hasta 60s probando POST /matchup mínimo
          for i in $(seq 1 60); do
            curl -fsS -X POST http://127.0.0.1:8080/matchup \
              -H "Content-Type: application/json" \
              -d '{"tournament":{"name":"Cincinnati","month":8},"years_back":4}' >/dev/null 2>&1 && break || true
            sleep 1
          done
          # si no arrancó, mostrar logs y fallar
          if ! curl -fsS -X POST http://127.0.0.1:8080/matchup -H "Content-Type: application/json" -d '{"tournament":{"name":"Cincinnati","month":8},"years_back":4}' >/dev/null 2>&1; then
            echo "::error::La app no respondió en 60s. ¿exportas 'app' en main.py y tienes Flask instalado?"; exit 1
          fi

      - name: (Smoke) POST /matchup con SR IDs
        if: ${{ env.RUN_SMOKE == 'true' }}
        run: |
          set -euo pipefail
          P1_SR_FULL="sr:competitor:${P1_SRID}"
          if [ -n "${P2_SRID:-}" ]; then
            P2_SR_FULL="sr:competitor:${P2_SRID}"
          else
            P2_SR_FULL="$P1_SR_FULL"
          fi

          PAYLOAD=$(jq -n --arg p "$P1_SR_FULL" --arg o "$P2_SR_FULL" \
                    '{player_id:$p, opponent_id:$o, tournament:{name:"Cincinnati",month:8}, years_back:4}')
          echo "== Payload /matchup ==" && echo "$PAYLOAD" | jq .

          RESP=$(curl -sS -X POST http://127.0.0.1:8080/matchup -H "Content-Type: application/json" -d "$PAYLOAD")
          echo "== Respuesta /matchup ==" && echo "$RESP" | jq .

          # Comprobar mapeo SR->UUID (idealmente ya no devuelve 'sr:' en inputs.player_id)
          echo "$RESP" | jq -e '.inputs.player_id|type=="string" and (.inputs.player_id|startswith("sr:")|not)' >/dev/null || \
            echo "::warning::inputs.player_id sigue siendo SR; revisa que ext_sportradar_id esté asignado en players."
