name: DB – Defense Points v2 (from estratego_v1 finals, dynamic schema)

on:
  workflow_dispatch:
    inputs:
      season_year:
        description: "Año previo a poblar (ej. 2024)"
        required: true
        default: "2024"

jobs:
  defense-points:
    runs-on: ubuntu-latest
    timeout-minutes: 25
    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      SEASON_YEAR: ${{ inputs.season_year }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install psql
        run: sudo apt-get update && sudo apt-get install -y postgresql-client

      - name: Sanity
        run: psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -c "select now();"

      - name: Write setup.sql (helper + table)
        run: |
          cat > /tmp/defense_setup.sql <<'SQL'
          -- Helper para clave normalizada de torneo
          CREATE OR REPLACE FUNCTION public.norm_tourney(txt text)
          RETURNS text LANGUAGE sql IMMUTABLE AS $$
            SELECT regexp_replace(lower(coalesce(txt,'')), '\s+', ' ', 'g')
          $$;

          -- Tabla destino (si no existe)
          CREATE TABLE IF NOT EXISTS public.player_defense_prev_year (
            tourney_key text NOT NULL,
            player_id   int  NOT NULL,
            points      int  NOT NULL,
            title_code  text,
            PRIMARY KEY (tourney_key, player_id)
          );
          SQL

      - name: Apply setup
        run: psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f /tmp/defense_setup.sql

      - name: Write dynamic backfill.sql (detect date & runner columns)
        run: |
          cat > /tmp/defense_backfill_dynamic.sql <<'SQL'
          DO $$
          DECLARE
            v_year int := current_setting('my.season_year', true)::int;
            -- Detectar nombre de columna fecha en estratego_v1.matches
            v_date_col text;
            v_has_loser boolean;
            v_has_opponent boolean;
            v_sql text;
          BEGIN
            SELECT column_name
            INTO v_date_col
            FROM information_schema.columns
            WHERE table_schema='estratego_v1'
              AND table_name='matches'
              AND column_name IN ('match_date','dt','date','start_time','start_dt','played_at')
            ORDER BY CASE column_name
              WHEN 'match_date' THEN 1
              WHEN 'dt'         THEN 2
              WHEN 'date'       THEN 3
              WHEN 'start_time' THEN 4
              WHEN 'start_dt'   THEN 5
              WHEN 'played_at'  THEN 6
              ELSE 100
            END
            LIMIT 1;

            IF v_date_col IS NULL THEN
              RAISE NOTICE 'No se encontró columna de fecha en estratego_v1.matches; usando match_id como proxy de final (sin filtro por año).';
            END IF;

            SELECT EXISTS (
              SELECT 1 FROM information_schema.columns
              WHERE table_schema='estratego_v1' AND table_name='matches' AND column_name='loser_id'
            ) INTO v_has_loser;

            SELECT EXISTS (
              SELECT 1 FROM information_schema.columns
              WHERE table_schema='estratego_v1' AND table_name='matches' AND column_name='opponent_id'
            ) INTO v_has_opponent;

            -- 1) Insertar CAMPEÓN
            IF v_date_col IS NOT NULL THEN
              v_sql := format($q$
                WITH finals AS (
                  SELECT m.tourney_id, MAX(m.%1$I) AS final_date
                  FROM estratego_v1.matches m
                  WHERE m.round='F' AND EXTRACT(YEAR FROM m.%1$I) = %2$L
                  GROUP BY 1
                ),
                final_rows AS (
                  SELECT m.tourney_id, m.%1$I AS match_dt, m.winner_id
                  FROM estratego_v1.matches m
                  JOIN finals f
                    ON m.tourney_id = f.tourney_id
                   AND m.%1$I      = f.final_date
                  WHERE m.round='F'
                ),
                tmap AS (
                  SELECT t.tourney_id, public.norm_tourney(t.name) AS tourney_key, t.level
                  FROM estratego_v1.tournaments t
                ),
                points AS (
                  SELECT 'G' AS level, 2000 AS champ, 1200 AS runner UNION ALL
                  SELECT 'M',             1000,          600         UNION ALL
                  SELECT 'A',              500,          300
                )
                INSERT INTO public.player_defense_prev_year (tourney_key, player_id, points, title_code)
                SELECT tm.tourney_key, fr.winner_id, p.champ, 'champ'
                FROM final_rows fr
                JOIN tmap tm USING (tourney_id)
                JOIN points p ON p.level = tm.level
                ON CONFLICT (tourney_key, player_id) DO UPDATE
                SET points=EXCLUDED.points, title_code=EXCLUDED.title_code;
              $q$, v_date_col, v_year);
            ELSE
              v_sql := $q$
                WITH finals AS (
                  SELECT m.tourney_id, MAX(m.match_id) AS final_match_id
                  FROM estratego_v1.matches m
                  WHERE m.round='F'
                  GROUP BY 1
                ),
                final_rows AS (
                  SELECT m.tourney_id, m.match_id AS final_match_id, m.winner_id
                  FROM estratego_v1.matches m
                  JOIN finals f
                    ON m.tourney_id = f.tourney_id
                   AND m.match_id   = f.final_match_id
                  WHERE m.round='F'
                ),
                tmap AS (
                  SELECT t.tourney_id, public.norm_tourney(t.name) AS tourney_key, t.level
                  FROM estratego_v1.tournaments t
                ),
                points AS (
                  SELECT 'G' AS level, 2000 AS champ, 1200 AS runner UNION ALL
                  SELECT 'M',             1000,          600         UNION ALL
                  SELECT 'A',              500,          300
                )
                INSERT INTO public.player_defense_prev_year (tourney_key, player_id, points, title_code)
                SELECT tm.tourney_key, fr.winner_id, p.champ, 'champ'
                FROM final_rows fr
                JOIN tmap tm USING (tourney_id)
                JOIN points p ON p.level = tm.level
                ON CONFLICT (tourney_key, player_id) DO UPDATE
                SET points=EXCLUDED.points, title_code=EXCLUDED.title_code;
              $q$;
            END IF;
            EXECUTE v_sql;

            -- 2) Insertar RUNNER-UP (si el esquema lo permite)
            IF v_has_loser THEN
              IF v_date_col IS NOT NULL THEN
                v_sql := format($q$
                  WITH finals AS (
                    SELECT m.tourney_id, MAX(m.%1$I) AS final_date
                    FROM estratego_v1.matches m
                    WHERE m.round='F' AND EXTRACT(YEAR FROM m.%1$I) = %2$L
                    GROUP BY 1
                  ),
                  final_rows AS (
                    SELECT m.tourney_id, m.%1$I AS match_dt, m.winner_id, m.loser_id AS runner_id
                    FROM estratego_v1.matches m
                    JOIN finals f
                      ON m.tourney_id = f.tourney_id
                     AND m.%1$I      = f.final_date
                    WHERE m.round='F'
                  ),
                  tmap AS (
                    SELECT t.tourney_id, public.norm_tourney(t.name) AS tourney_key, t.level
                    FROM estratego_v1.tournaments t
                  ),
                  points AS (
                    SELECT 'G' AS level, 2000 AS champ, 1200 AS runner UNION ALL
                    SELECT 'M',             1000,          600         UNION ALL
                    SELECT 'A',              500,          300
                  )
                  INSERT INTO public.player_defense_prev_year (tourney_key, player_id, points, title_code)
                  SELECT tm.tourney_key, fr.runner_id, p.runner, 'runner'
                  FROM final_rows fr
                  JOIN tmap tm USING (tourney_id)
                  JOIN points p ON p.level = tm.level
                  ON CONFLICT (tourney_key, player_id) DO UPDATE
                  SET points=EXCLUDED.points, title_code=EXCLUDED.title_code;
                $q$, v_date_col, v_year);
              ELSE
                v_sql := $q$
                  WITH finals AS (
                    SELECT m.tourney_id, MAX(m.match_id) AS final_match_id
                    FROM estratego_v1.matches m
                    WHERE m.round='F'
                    GROUP BY 1
                  ),
                  final_rows AS (
                    SELECT m.tourney_id, m.match_id AS final_match_id, m.winner_id, m.loser_id AS runner_id
                    FROM estratego_v1.matches m
                    JOIN finals f
                      ON m.tourney_id = f.tourney_id
                     AND m.match_id   = f.final_match_id
                    WHERE m.round='F'
                  ),
                  tmap AS (
                    SELECT t.tourney_id, public.norm_tourney(t.name) AS tourney_key, t.level
                    FROM estratego_v1.tournaments t
                  ),
                  points AS (
                    SELECT 'G' AS level, 2000 AS champ, 1200 AS runner UNION ALL
                    SELECT 'M',             1000,          600         UNION ALL
                    SELECT 'A',              500,          300
                  )
                  INSERT INTO public.player_defense_prev_year (tourney_key, player_id, points, title_code)
                  SELECT tm.tourney_key, fr.runner_id, p.runner, 'runner'
                  FROM final_rows fr
                  JOIN tmap tm USING (tourney_id)
                  JOIN points p ON p.level = tm.level
                  ON CONFLICT (tourney_key, player_id) DO UPDATE
                  SET points=EXCLUDED.points, title_code=EXCLUDED.title_code;
                $q$;
              END IF;
              EXECUTE v_sql;

            ELSIF v_has_opponent THEN
              -- Derivar runner con opponent_id/player_id
              IF v_date_col IS NOT NULL THEN
                v_sql := format($q$
                  WITH finals AS (
                    SELECT m.tourney_id, MAX(m.%1$I) AS final_date
                    FROM estratego_v1.matches m
                    WHERE m.round='F' AND EXTRACT(YEAR FROM m.%1$I) = %2$L
                    GROUP BY 1
                  ),
                  final_rows AS (
                    SELECT m.tourney_id, m.%1$I AS match_dt, m.winner_id,
                           CASE WHEN m.player_id = m.winner_id THEN m.opponent_id ELSE m.player_id END AS runner_id
                    FROM estratego_v1.matches m
                    JOIN finals f
                      ON m.tourney_id = f.tourney_id
                     AND m.%1$I      = f.final_date
                    WHERE m.round='F'
                  ),
                  tmap AS (
                    SELECT t.tourney_id, public.norm_tourney(t.name) AS tourney_key, t.level
                    FROM estratego_v1.tournaments t
                  ),
                  points AS (
                    SELECT 'G' AS level, 2000 AS champ, 1200 AS runner UNION ALL
                    SELECT 'M',             1000,          600         UNION ALL
                    SELECT 'A',              500,          300
                  )
                  INSERT INTO public.player_defense_prev_year (tourney_key, player_id, points, title_code)
                  SELECT tm.tourney_key, fr.runner_id, p.runner, 'runner'
                  FROM final_rows fr
                  JOIN tmap tm USING (tourney_id)
                  JOIN points p ON p.level = tm.level
                  ON CONFLICT (tourney_key, player_id) DO UPDATE
                  SET points=EXCLUDED.points, title_code=EXCLUDED.title_code;
                $q$, v_date_col, v_year);
              ELSE
                v_sql := $q$
                  WITH finals AS (
                    SELECT m.tourney_id, MAX(m.match_id) AS final_match_id
                    FROM estratego_v1.matches m
                    WHERE m.round='F'
                    GROUP BY 1
                  ),
                  final_rows AS (
                    SELECT m.tourney_id, m.match_id AS final_match_id, m.winner_id,
                           CASE WHEN m.player_id = m.winner_id THEN m.opponent_id ELSE m.player_id END AS runner_id
                    FROM estratego_v1.matches m
                    JOIN finals f
                      ON m.tourney_id = f.tourney_id
                     AND m.match_id   = f.final_match_id
                    WHERE m.round='F'
                  ),
                  tmap AS (
                    SELECT t.tourney_id, public.norm_tourney(t.name) AS tourney_key, t.level
                    FROM estratego_v1.tournaments t
                  ),
                  points AS (
                    SELECT 'G' AS level, 2000 AS champ, 1200 AS runner UNION ALL
                    SELECT 'M',             1000,          600         UNION ALL
                    SELECT 'A',              500,          300
                  )
                  INSERT INTO public.player_defense_prev_year (tourney_key, player_id, points, title_code)
                  SELECT tm.tourney_key, fr.runner_id, p.runner, 'runner'
                  FROM final_rows fr
                  JOIN tmap tm USING (tourney_id)
                  JOIN points p ON p.level = tm.level
                  ON CONFLICT (tourney_key, player_id) DO UPDATE
                  SET points=EXCLUDED.points, title_code=EXCLUDED.title_code;
                $q$;
              END IF;
              EXECUTE v_sql;

            ELSE
              RAISE NOTICE 'No hay loser_id ni opponent_id en estratego_v1.matches → se inserta solo campeón.';
            END IF;

          END $$;
          SQL

      - name: Execute dynamic backfill
        env:
          season_year: ${{ inputs.season_year }}
        run: |
          # Pasamos el parámetro como GUC temporal accesible desde el DO block:
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -c "SET my.season_year TO '${season_year}';" -f /tmp/defense_backfill_dynamic.sql

      - name: Export CSV artifact (joined with tournament name/level)
        run: |
          mkdir -p /tmp/defense_artifacts
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 <<'SQL' > /tmp/defense_artifacts/defense_points_prev_year.csv
          COPY (
            SELECT
              pd.tourney_key,
              t.name AS tournament_name,
              t.level,
              pd.player_id,
              pd.points,
              pd.title_code
            FROM public.player_defense_prev_year pd
            LEFT JOIN estratego_v1.tournaments t
              ON public.norm_tourney(t.name) = pd.tourney_key
            ORDER BY pd.tourney_key, pd.points DESC, pd.player_id
          ) TO STDOUT WITH CSV HEADER;
          SQL
          echo "CSV rows:"; wc -l /tmp/defense_artifacts/defense_points_prev_year.csv || true
          head -n 12 /tmp/defense_artifacts/defense_points_prev_year.csv || true

      - name: Verify sample table view
        run: |
          echo ">>> Sample (20):"
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -c "
            SELECT *
            FROM public.player_defense_prev_year
            ORDER BY tourney_key, points DESC, player_id
            LIMIT 20;
          "

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: defense_points_prev_year_v2
          path: /tmp/defense_artifacts/defense_points_prev_year.csv
          retention-days: 7
